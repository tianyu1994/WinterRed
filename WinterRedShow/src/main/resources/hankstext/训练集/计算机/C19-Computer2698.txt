软件学报
JOURNAL OF SOFTWARE
1999年　第10卷　第11期　Vol.10　No.11　1999



启发式任务调度中的处理器选择策略
陈华平　黄刘生
　　摘要　任务调度是并行分布计算中最为基本、最为关键,也最具有挑战性的问题之一,是影响并行分布计算执行效率的一个关键因素.现有的基于任务静态优先级的启发式任务调度方法都是以“当前任务具有最早起始执行时刻”为目标来选择执行处理器.该文在详细分析讨论该种调度方法的基础上,指出了以该目标选择处理器存在的问题及缺点,并提出了以“当前任务的直接后继具有最早起始执行时刻”为目标选择处理器的方法,并给出了相应的约束条件.
　　关键词　并行分布计算,启发式任务调度,处理器选择.
　　中图法分类号　TP316
Processor Selection Policy in Heuristic Task Scheduling
CHEN Hua-ping HUANG Liu-sheng
(National High Performance Computing Center Hefei 230027)
(Department of Computer Science and Technology University of Science and Technology of China Hefei 230027)
　　Abstract　 As one of the most fundmental, critical and challengable problems in PDC (parallel distributed computing), task scheduling has great influence on the execution efficiency of PDC. The existing heuristic task schedulings based on static task priorities always use it as processor selection policy to make the current task have earliest start execution time. On the basis of analysis of the mechanism in priority-based heuristic task scheduling, the authors illustrate the drawbacks of the processor selection policy mentioned above, and propose a new processor selection policy, i.e, to make the successor of the current task have the earliest start time, and give the corresponding restraint.
　　Key words　Parallel distributed computing, heuristic task scheduling, processor selection.
　　既然并行分布计算中一般的任务调度问题均具有NP难度,那么,利用任务图本身所包含的一些启发信息来获得最优调度的近似解是经常被采用的一种技术方法.其中基于任务静态优先级的启发式任务调度方法,即表调度（list scheduling）是并行分布计算中最为常用的一种任务调度技术［1～3］.它的主要思想是,在编译时给任务图中的每个任务按一定规则赋一优先级,并且把当前的所有就绪任务按优先级的大小排列,建立一个就绪任务队列RTQ.然后,每次从队列中选择优先级最高的任务（称该任务为当前任务）,按一定规则把该任务分配到合适的处理器上,并计算出此任务在该处理器上的起始执行时刻,最后获得以Gantt图［1,4］形式表示的整个任务图的调度结果.
　　目前,基于表调度的这类启发式任务调度算法很多.但它们的思想都很相似,主要区别在于给任务赋优先级的方式有所不同.有些是在基本表调度算法基础上通过任务插入和任务复制等技术来提高启发式任务调度算法的执行性能［2,5］,这些算法均以“当前任务具有最早起始执行时刻”为目标来选择该当前任务的执行处理器号.本文的主要工作就是在分析基本的表调度算法和其改进算法的基础上,指出表调度算法中单以“当前任务具有最早起始执行时刻”为目标选择执行处理器存在的问题及缺点,并提出了以“当前任务的直接后继具有最早起始执行时刻”为目标选择处理器的方法,同时给出了相应的约束条件.
1 基本模型及定义
　　通常,一个并行程序的性质可用(V,,［dij］,w(ai))来刻画,偏序关系“”一般用任务图G=(V,E)来表示,其中V={ai｜i=1,2,...,n},为表示n个任务的有权结点,任务ai的工作负载w(ai)为该结点的权重;E={(ai,aj)｜ai,aj∈V}为表示任务间通信关系的带权有向边,dij为任务ai到aj的通信量;IMP(ai)={ak｜(ak,ai)∈E)},表示任务图中任务ai的直接前趋集,IMS(aj)={ak｜(aj,ak)∈E)},表示任务图中任务aj的直接后继集.
　　任务图的一个调度其实就是任务图G到目标机器的一个映射f:V｜→{1,2,...,m}×［0,∞),f(ai)=(p,t),表示任务ai被调度到编号为p的处理器上,起始执行时间为t.一般地,我们可用Gantt图GC={(p(ai),t(ai))｜ai∈V}来表示调度结果,其中函数p(ai)表示分配给任务ai的处理器号,t(ai)表示任务ai的起始执行时刻.
　　定义1. 设ai为任务图的一个结点,如果IMP(ai)=,则称结点ai为入口结点;如果IMS(aj)=,则称结点aj为出口结点.
　　定义2. 任务图中结点ai到结点aj的一条路径的计算长度为该路径上包括起始结点ai和终止结点aj在内的所有结点的权重之和.
　　定义3. 任务图中一个结点的出口长度为从该结点到出口结点的最大计算长度.结点的入口长度为从入口结点到该结点的最大计算长度.
　　很明显,一般情况下,出口长度大的任务或入口长度小的任务优先执行.当采用任务结点的入口长度作为该任务优先级的主要部分时,那么结点的出口长度就成为主要调度启发信息.另外,入口长度、关键路径等也是常用的一种调度启发信息.在以下的算法中,我们就用结点的出口长度作为主要启发信息.当两个结点的出口长度相同时,可进一步通过它们的直接后继结点的数目来决定它们的优先级的大小.
　　如果已经把一个任务调度到某一处理器上,那么我们称该任务是已分配的.如果结点任务ai的直接前趋已全部分配完毕,可把该结点作为就绪任务插入到就绪任务队列RTQ中,插入后,RTQ还是保持按照上面定义的优先级大小排列.很明显,一开始只有入口结点任务为就绪任务.在就绪任务队列中具有最高优先级的队首任务也叫当前分配任务,用ac来表示,被选中执行ac的处理器也叫当前处理器.
　　在分布存储的并行计算模型上,严格地讲,像出口长度这样的启发信息应该包括通信延迟.但是,任务间的通信延迟与这两个任务所分配处理器的位置有关,把同一结点调度到不同处理器上所产生的通信延迟是不同的.例如,任务ai与aj之间的通信量为dij≠0,如果ai与aj被调度到同一处理器上,那么它们之间的通信延迟可以忽略,否则,就必须考虑这个通信延迟.事实上,如果目标机器是异构的,那么各处理器的执行速度也不尽相同,这时,同一任务分配到不同处理器上的计算时间也是不一样的,所以,在这时的任务图中各结点的权重也是可变的,因而结点的出口长度和入口长度也是可变的.在下面的分析讨论中,假定处理器之间是全连接的,任务图中的任务结点权重和通信边权重已换算成同一时间单位,并且通信边权重已包含消息传递启动时间.
2 表调度算法的基本思想
　　为了在分布存储的并行模型上采用静态的启发式任务调度算法,我们也可用结点的出口计算长度作为主要启发信息,但在求解任务ai的起始执行时刻时,还必须考虑ai的所有直接前趋任务与ai之间的通信延迟带来的开销.其实,在给一个任务ai分配处理器时,优先考虑包含IMP(ai)结点的处理器,通过把消息传递量较大的源结点和目标结点放在同一处理器上以减少通信延迟.
设任务ai在处理器p(ai)上的起始执行时刻为est(ai,p(ai)),执行完成时刻为ect(ai,p(ai)),那么,ect(ai,p(ai))=est(ai,p(ai))+w(ai).
　　定义4. 设一个任务au在处理器Pv上的消息就绪时刻用mrdt(au,Pv)表示,它为任务au在Pv上执行时,接收到所需全部消息的最早时刻.
　　一个任务的消息就绪时刻主要由它的直接前趋任务结点所决定,即
mrdt(au,Pv)=maxak∈IMP(au){ect(ak,p(ak))+dku}.
（1）
　　一个任务的消息就绪时刻与该任务所在的处理器有关,如果一个任务被分配到它的某一前趋所在处理器上的话,那么与该直接前趋的通信延迟可忽略.使式（1）取得最大值的前趋任务也叫做任务au的关键前趋,由于au的每个直接前趋任务的执行完成时刻不同,所以,au的关键前趋不一定是与au间通信量最大的直接前趋.
　　如果想把任务au分配在Pv上执行,那么至少要等到消息就绪时刻mrdt(au,Pv)才有可能开始执行,至于到该时刻能否真正开始执行,还要看Pv上已分配的其他任务的执行情况.我们把一个处理器已执行完其上面已分配任务的时刻称为该处理器的就绪时刻,用prdt(Pi)来表示处理器Pi的就绪时刻,如果不考虑消息就绪时刻的话,它也就是Pi能执行其他再分配任务的最早时刻.在整个系统中,当前具有最早就绪时刻的处理器称为最先就绪处理器.
　　根据上面的分析可知,如果把一个任务au分配到处理器Pv上执行,那么任务au在Pv上的最早起始执行时刻为
est(au,Pv)=max{prdt(Pv),mrdt(au,Pv)}.
（2）
　　目前,并行分布计算中基于表调度的启发式任务调度算法就是按照式（2）来选择使当前任务具有最早起始执行时刻的处理器.
　　图1是一个示例任务图,把每个任务的出口计算长度作为该任务的优先级.图2是以出口计算长度为启发信息的表调度算法LS1对该任务图进行调度所获得的Gantt图,其调度长度为12.

图1 示例任务图

图2 LS1所求得的Gantt图
　　现在对图2稍加分析观察可知,对调度长度具有直接影响的是任务执行序列(a1,a3,a4,a5,a6,a7),这个序列我们也称为关键任务序列.从图2简单地来看,任务a5似乎对调度长度影响不大,但实际上,正是因为a5到a6也存在较大的通信延迟,使得a6不能与a4放在同一个处理器上,所以,a5也对调度长度有直接影响,也属于关键任务序列.而任务a2虽然具有较高的优先级,但是从图2可以看出,即使晚一些执行a2,也不会对调度长度产生什么影响.既然直接影响调度长度的是关键任务序列,那么任务调度算法能否优先考虑该关键任务序列的执行呢?实际上,在获得表示调度结果的Gantt图之前,我们并不了解直接影响调度长度的关键任务序列,通过图1与图2对比可发现,(a1,a3,a4,a6,a7)刚好是示例任务图的关键路径.一般情况下,关键路径与关键任务序列并不一定相同,但我们可以利用关键路径作为主要启发信息进行任务调度.
　　关键路径上的任务偏序关系是确定的.以关键路径作为主要启发信息的表调度算法LS2根据关键路径上任务的偏序关系选择任务ai,依消息就绪时刻的非增次序选择IMP(ai)中的任务结点au,然后按照任务au能获得最早起始时刻为目标选择处理器号,同时也确定了它的执行时刻,最后,参照上面定义的任务优先级调度G中其余的结点,这些结点的执行对关键路径上的任务没有影响.图3显示了LS2算法对图1的调度结果,很明显,调度长度比图2少1.

图3 LS2所求得的Gantt图
3 对目标处理器选择规则的改进
　　通过对图2和图3的分析观察可以发现,不管把任务a6放到哪个处理器上执行,由于任务a4与a5到任务a6的通信量都比较大,而a4与a5又放在不同的处理器上,所以a6不可能有较早的起始执行时刻.但是,如果把任务a4与a5分配到同一处理器上执行,如图4所示,这时反而能获得较短的调度长度,调度长度为8.分析其原因可以发现,在上面的启发式调度算法中,主要基于以每个当前任务ac具有最早的起始执行时刻为目标来选择处理器,其目的就是为了使该任务的后继结点有可能尽早开始执行,以此类推,最终目标就是使出口结点能尽早执行,从而使调度长度较小.

图4 选择策略改进后的调度结果
　　但是,局部最优调度某任务ac使其具有最早起始执行时刻这种思想忽略了这样一个事实,即IMS(ac)的其他已分配直接前趋与ac一起,对IMS(ac)的最早起始执行时刻是相互作用、相互影响的.有时在某些条件下,如果局部地以当前任务ac具有最早起始执行时刻来选择处理器,反而使得IMS(ac)中的某些结点不能尽早执行.例如图2,如果在给任务a5分配处理器P3时,再进一步测试如果把a5分配到与a4相同的处理器上时,能否使它们的共同直接后继结点a6的起始执行时刻提前.很明显,如果把a5放到与a4相同的处理器上,与把a5分配到处理器P3相比,虽然a5晚0.5个时间单位开始执行,违背了以当前任务具有最早起始执行时刻为目标选择处理器的规则,但它有可能使得a4,a5到a6的通信延迟都为零（只要把a6分配到与a4,a5相同的处理器上即可）,因而把a6的起始执行时刻提早到6,并且只需要两个处理器就能获得这个调度长度,所以这时就不能单以a5具有最早起始执行时刻来选择处理器.
　　既然局部地以当前任务具有最早起始执行时刻为目标来分配处理器并不能获得较小的调度长度,那么到底在什么样情况下,我们才考虑把同为某一结点的一些直接前趋任务分配到同一处理器上呢？还是以图2与图4为例来说明,以a4,a5和a6这3个任务的局部小范围调度而言,如果不断增加a5的计算时间,那么图4的调度长度就会相应地增加,而图2的调度长度不变,因此,把a5与a4分配到同一处理器上所获得的收益也相对减小.当a5的计算时间增加到5时,图4中把a5与a4分配到同一处理器上所获得的调度长度也为12,与图2相同.如果a5的计算时间大于5,这时图4中把a5与a4分配到同一处理器上所获得的调度长度将大于12.
　　如果a5的计算时间保持不变,而不断减小a4到a6的通信时间,也会使图2的调度长度不断减小,而图4的调度长度不变.当a4到a6的通信时间减小到1时,图2的调度长度也为8,与图4相同.同样地,如果考虑减少a5到a6的通信时间,也会使得图2的调度长度不断减小.与减小a4到a6的通信时间所不同的是,这时应把a6分配到与a4相同的处理器上.
　　一般地,在选定使ac具有最早起始执行时刻的处理器p(ac)以后,还要进一步测试与ac具有相同后继ai的其他已分配的直接前趋,从中选择其执行处理器不为p(ac)(即p(aj)≠p(ac)),并且到p(ac)具有最大消息就绪时刻的任务aj,然后检查是否满足下面的条件:
est(ac,p(aj))+w(ac)＜ect(aj,p(aj))+dji.
(3)
　　如果满足上式条件,那么很明显,把ac分配到p(aj)上时,就有可能使它们共同的直接后继结点ai的起始执行时刻提前.
　　定理1. 设一个任务结点au的直接前趋集为{au1,au2,...,auk},aur是使max{(ect(auj,p(auj))+duju0)｜j=1,2,...,k}取得最大值的结点,其中u0=u.如果任给y=1,2,...,k且y≠r,满足duju0≤w(aur)-(est(auy,p(auy))-est(aur,p(aur))),那么把任务au分配到p(aur)上,这样总能使任务au具有最早的起始执行时刻Tu,Tu=max{ect(aur,p(aur)),(ect(auj,p(auj))+duju0)｜j=1,2,...,k,且j≠r}.
　　证明:可分两种情形来说明.
　　(1) 如果上式中的Tu是由ect(aur,p(aur))取得,那么,ect(aur,p(aur))≥(ect(auj,p(auj))+duju0)｜j=1,2,...,k,且j≠r),也就是说,在aur执行完以前,au的所有其他直接前趋任务的消息可以传送到处理器p(aur)上,所以,任务au不可能有比ect(aur,p(aur))更早的起始执行时刻.
　　(2) 如果上式中的Tu是由max{(ect(auj,p(auj))+duju0)｜j=1,2,...,k,且j≠r}取得,不妨设j=q时取得最大值,那么可以通过两种途径来减小Tu.
　　(2.1) 把au分配到处理器p(auq)上,这时,Tu=max{ect(auq,p(auq)),(ect(auj,p(auj))+duju0)｜j=1,2,...,k,且j≠q}.根据条件,ect(aur,p(aur))+duru0具有最大值,所以
ect(aur,p(aur))+duru0≥ect(auq,p(auq))+duqu0＞ect(auq,p(auq)).
因此,这时,Tu=ect(aur,p(aur))+duru0,即反而增大了au的起始执行时刻.
　　(2.2) 把任务auq与aur放到同一处理器上,根据条件
duyu0≤w(aur)-(est(auy,p(auy))-est(aur,p(aur))), 其中y=1,2,...,k且y≠r,
可得
est(aur,p(aur))+w(aur)≥est(auq,p(auq))+duqu0.
　　在不等式两边同时加上w(auq)，可得
est(aur,p(aur))+w(aur)+w(auq)≥est(auq,p(auq))+w(auq)+duqu0,
即
ect(aur,p(aur))+w(auq)≥ect(auq,p(auq))+duqu0.
　　定理1给出了在什么条件下使用以“当前任务具有最早起始执行时刻”为目标选择执行处理器才比较有效,而当拥有相同后继结点的任务间满足条件(3)时,应以“当前任务的后继结点具有最早起始执行时刻”为目标来选择执行处理器.
4 结 论
　　目前,基于任务静态优先级的启发式任务调度算法都是以“当前任务具有最早起始执行时刻”为目标选择执行处理器,但在某些条件下,这反而会引起后继结点的延迟执行.本文在详细分析讨论了该种调度策略的基础上,指出了以该目标选择执行处理器所存在的不足之处,并提出了以“当前任务的直接后继具有最早起始执行时刻”为目标选择处理器的调度方法,同时给出了相应的约束条件.
基金项目：本文研究得到国家863高科技项目基金和安徽省自然科学基金资助.
作者简介：陈华平,1965年生,博士,副教授,主要研究领域为并行分布计算,网络计算.
　　　　　黄刘生,1957年生,副教授，主要研究领域为分布算法,OODB.
作者单位：国家高性能计算中心 合肥 230027
　　　　　中国科学技术大学计算机科学技术系 合肥 230027
　　　　　E-mail: hpchen@ustc.edu.cn
本文通讯联系人:陈华平，合肥 230027,国家高性能计算中心
参考文献
　1 El-Rewini H, Lewis T G, Ali H H. Task Scheduling. New Jersey: PTR Prentice Hall, 1994. 56～78
　2 陈华平,林洪,陈国良.并行分布计算中的启发式任务调度.计算机研究与发展,1997,34（增刊）:74～78
(Chen Hua-ping, Lin Hong, Chen Guo-liang. Heuristic task scheduling in parallel distributed computing. Computer Research and Development, 1997,34(supplement):74～78)
　3 Sevcik K C. Application scheduling and processor allcation in multiprogrammed parallel processing systems. Performance Evaluation, 1994,19(2/3):107～140
　4 陈华平,李京,陈国良.并行分布计算中的任务调度问题(1).计算机科学,1997,24（2）:23～27
(Chen Hua-ping, Li Jing, Chen Guo-liang. Task scheduling in parallel distributed computing (Part 1). Computer Science, 1997,24(2):23～27)
　5 Ahmad I, Kwork Y K. A new approach to scheduling parallel programs using task duplication. In: Proceedings of the International Conference on Parallel Processing. Los Alamitos: IEEE Computer Society Press, 1994. 326～333
本文1998-09-18收到原稿,1999-03-01收到修改稿
